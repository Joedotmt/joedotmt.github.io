<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBQ Date Picker</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/pocketbase/dist/pocketbase.umd.js"></script>
    <link rel="stylesheet" type="text/css" href="https://npmcdn.com/flatpickr/dist/themes/dark.css">

    <link href="https://cdn.jsdelivr.net/npm/beercss@3.11.11/dist/cdn/beer.min.css" rel="stylesheet" />
    <script type="module" src="https://cdn.jsdelivr.net/npm/beercss@3.11.11/dist/cdn/beer.min.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/material-dynamic-colors@1.1.2/dist/cdn/material-dynamic-colors.min.js"></script>
    <style>
        body {
            padding: 0;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        input.flatpickr-input {
            width: 100%;
            border: none;
            border: 1px solid var(--outline);
            padding: 12px 0;
            font-size: 1rem;
            background-color: transparent;
            color: var(--on-surface);
        }

        input.flatpickr-input:focus {
            border-bottom: 2px solid var(--primary);
            outline: none;
        }

        .card {
            margin-bottom: 1.5rem;
            border-radius: var(--medium-shape);
        }

        .loader {
            width: 24px;
            height: 24px;
            border: 3px solid var(--surface-variant);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 0.5rem;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #messageArea {
            padding: 0.75rem;
            border-radius: var(--small-shape);
            text-align: center;
            margin-top: 1rem;
            margin-bottom: 1rem;
            display: none;
        }

        .message-success {
            background-color: var(--primary-container);
            color: var(--on-primary-container);
        }

        .message-error {
            background-color: var(--error-container);
            color: var(--on-error-container);
        }

        .date-count-item {
            padding: 0.75rem;
            border: 1px solid var(--outline);
            border-radius: var(--small-shape);
            margin-bottom: 0.75rem;
            background-color: var(--surface-container);
            transition: background-color 0.3s, border-color 0.3s;
        }

        .date-count-item .date-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.35rem;
        }

        .date-count-item .date-value {
            color: var(--on-surface);
        }

        .date-count-item .availability-count {
            font-weight: bold;
            color: var(--primary);
        }

        .date-count-item .attendees-list {
            color: var(--on-surface-variant);
            font-size: 0.9em;
            margin-top: 0.25rem;
        }

        .date-count-item .chip {
            margin-top: 0.5rem;
            display: inline-block;
        }

        .date-count-item.most-popular {
            border: 2px solid var(--primary);
            background-color: var(--primary-container);
        }

        .date-count-item.most-popular .date-value {
            color: var(--on-primary-container);
        }

        .date-count-item.most-popular .availability-count {
            color: var(--primary);
        }

        .date-count-item.most-popular .attendees-list {
            color: var(--on-primary-container);
        }

        .date-count-item.single-attendee {
            background-color: var(--surface-container-lowest);
            border-color: var(--outline-variant);
        }

        .date-count-item.single-attendee .date-value,
        .date-count-item.single-attendee .availability-count,
        .date-count-item.single-attendee .attendees-list {
            color: var(--on-surface-variant);
        }

        #allSubmissions li {
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--outline-variant);
        }

        #allSubmissions li:last-child {
            border-bottom: none;
        }

        header h1 {
            color: var(--primary);
        }

        header p {
            color: var(--on-surface-variant);
        }

        .card h2,
        .card h3 {
            color: var(--on-surface);
            margin-bottom: 0.75rem;
        }

        .label-like {
            display: block;
            color: var(--on-surface-variant);
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body class="dark">
    <div class="container">
        <header class="center-align large-padding no-round bottom-round">
            <h1 class="large-title">Joe's BBQ Date Deciderer</h1>
            <p class="medium-text">Results update automatically!!!!!1!1!</p>
        </header>

        <nav class="center-align large-padding">
            <button class="primary large round ripple" onclick="ui('#upload-dates-dialog')">
                <i>event_available</i>
                Submit Your Availability
            </button>

            <span id="userDisplay" class="medium-text" style="margin-left:1rem; color:var(--on-surface-variant);"></span>
            <button id="signInBtn" class="round border ripple" style="margin-left:1rem;" onclick="signIn()">
                <i>login</i> Sign In
            </button>
            <button id="signOutBtn" class="round border ripple hidden" style="margin-left:0.5rem;" onclick="signOut()">
                <i>logout</i> Sign Out
            </button>
        </nav>

        <dialog id="upload-dates-dialog" class="large bottom">
            <article class="card round large-padding">
                <h2 class="large-text">Submit Your Availability</h2>
                <form id="dateForm">
                    <div class="field large prefix border round">
                        <i>calendar_month</i>
                        <input type="text" id="dates" name="dates" required placeholder="Click to pick dates">
                    </div>

                    <nav class="right-align" style="gap: 0; margin-top: 3em;">
                        <button type="submit" class="primary round ripple" id="submitButton">
                            <span>Submit Availability</span>
                            <i class="loader hidden" id="submitLoading"></i>
                        </button>
                        <button type="button" class="round border ripple" onclick="ui('#upload-dates-dialog')" style="margin-left:1rem;">
                            Cancel
                        </button>
                    </nav>
                </form>
            </article>
        </dialog>

        <div id="messageArea" role="alert"></div>

        <article class="card top-round" style="margin-bottom: 0;">
            <h2 class="large-text">Current Poll Results</h2>
            <div id="connectionStatus" class="small-text center-align small-margin"></div>
            <div id="resultsLoading" class="center-align medium-padding hidden">
                <progress class="circle large"></progress>
                <p>Loading results...</p>
            </div>
            <div id="resultsError" class="small-text center-align medium-padding hidden" role="alert"></div>

            <div id="resultsContainer">
                <section class="medium-padding">
                    <h3 class="medium-text">ðŸ“… All Chosen Dates:</h3>
                    <div id="popularDates">
                        <p class="small-text">Waiting for data...</p>
                    </div>
                </section>

                <div class="divider"></div>

                <section class="medium-padding">
                    <h3 class="medium-text">ðŸ“‹ All Individual Submissions:</h3>
                    <ul id="allSubmissions">
                        <p class="small-text">Waiting for data...</p>
                    </ul>
                </section>
            </div>
        </article>
    </div>

    <script>
        // --- Configuration ---
        const POCKETBASE_URL = 'https://joemt.fly.dev/';
        const COLLECTION_NAME = 'bbq_poll';

        // --- DOM Elements ---
        const dateForm = document.getElementById('dateForm');
        const datesInput = document.getElementById('dates');
        const submitLoading = document.getElementById('submitLoading');
        const resultsLoading = document.getElementById('resultsLoading');
        const resultsError = document.getElementById('resultsError');
        const connectionStatus = document.getElementById('connectionStatus');
        const popularDatesDiv = document.getElementById('popularDates');
        const allSubmissionsUl = document.getElementById('allSubmissions');
        const messageArea = document.getElementById('messageArea');
        const signInBtn = document.getElementById('signInBtn');
        const signOutBtn = document.getElementById('signOutBtn');
        const userDisplay = document.getElementById('userDisplay');

        let pb = null;
        let unsubscribeCallback = null;
        let flatpickrInstance;

        function initializeFlatpickr() {
            flatpickrInstance = flatpickr(datesInput, {
                mode: "multiple",
                dateFormat: "Y-m-d",
                minDate: "today",
                locale: {
                    firstDayOfWeek: 1
                }
            });
        }

        function showMessage(message, type = 'success', duration = 5000) {
            messageArea.textContent = message;
            messageArea.className = '';
            if (type === 'success') {
                messageArea.classList.add('message-success');
            } else {
                messageArea.classList.add('message-error');
            }
            messageArea.style.display = 'block';
            if (duration > 0) {
                setTimeout(() => {
                    messageArea.textContent = '';
                    messageArea.style.display = 'none';
                }, duration);
            }
        }

        function updateConnectionStatus(message, isError = false) {
            connectionStatus.textContent = message;
            connectionStatus.style.color = isError ? 'var(--error)' : 'var(--primary)';
        }

        async function initializePocketBaseClient() {
            updateConnectionStatus('Initializing PocketBase client...', false);
            
            pb = new PocketBase(POCKETBASE_URL);
            pb.autoCancellation(false);

            if (pb.authStore.isValid) {
                updateConnectionStatus('Authenticated. Subscribing to updates...', false);
                showSignedInState();
                await subscribeToRealtime();
            } else {
                updateConnectionStatus('Not signed in. Click "Sign In" to authenticate.', true);
                showSignedOutState();
            }

            await fetchAndDisplayResults();
        }

        async function subscribeToRealtime() {
            try {
                if (unsubscribeCallback) {
                    await unsubscribeCallback();
                    unsubscribeCallback = null;
                }
                
                unsubscribeCallback = await pb.collection(COLLECTION_NAME).subscribe('*', function (e) {
                    console.log('Realtime event:', e.action, e.record);
                    showMessage(`Data updated: ${e.action}.`, 'success', 2000);
                    fetchAndDisplayResults();
                });
                
                updateConnectionStatus('Subscribed to real-time updates.', false);
            } catch (error) {
                console.warn('Realtime subscribe error:', error);
                updateConnectionStatus('Could not subscribe to real-time updates.', true);
            }
        }

        function showSignedInState() {
            signInBtn.classList.add('hidden');
            signOutBtn.classList.remove('hidden');
            const user = pb?.authStore?.model;
            const name = user?.name || user?.username || user?.email || '';
            userDisplay.textContent = name ? `Signed in: ${name}` : 'Signed in';
        }

        function showSignedOutState() {
            signInBtn.classList.remove('hidden');
            signOutBtn.classList.add('hidden');
            userDisplay.textContent = '';
            
            if (unsubscribeCallback) {
                unsubscribeCallback().catch(e => console.warn('Error unsubscribing:', e));
                unsubscribeCallback = null;
            }
        }

        function signIn() {
            const returnUrl = window.location.href;
            window.location.href = `/account/?redirect=${encodeURIComponent(returnUrl)}`;
        }

        async function signOut() {
            if (!pb) pb = new PocketBase(POCKETBASE_URL);
            
            if (unsubscribeCallback) {
                await unsubscribeCallback();
                unsubscribeCallback = null;
            }
            
            pb.authStore.clear();
            showMessage('Signed out.', 'success', 2000);
            showSignedOutState();
            updateConnectionStatus('Signed out. Click "Sign In" to authenticate.', true);
            await fetchAndDisplayResults();
        }

        async function fetchAndDisplayResults() {
            if (!pb) {
                resultsLoading.classList.add('hidden');
                return;
            }

            resultsLoading.classList.remove('hidden');
            resultsError.classList.add('hidden');
            popularDatesDiv.innerHTML = '<p class="small-text">Loading...</p>';
            allSubmissionsUl.innerHTML = '<p class="small-text">Loading...</p>';

            try {
                const records = await pb.collection(COLLECTION_NAME).getFullList({
                    sort: '-created',
                    expand: 'user'
                });

                if (records.length === 0) {
                    popularDatesDiv.innerHTML = '<p class="small-text">No submissions yet. Be the first!</p>';
                    allSubmissionsUl.innerHTML = '<p class="small-text">No submissions yet.</p>';
                    resultsLoading.classList.add('hidden');
                    return;
                }

                // Aggregate dates
                const dateCounts = {};
                records.forEach(record => {
                    if (record.available_dates && Array.isArray(record.available_dates)) {
                        record.available_dates.forEach(dateStr => {
                            if (!dateCounts[dateStr]) {
                                dateCounts[dateStr] = { count: 0, people: [] };
                            }
                            dateCounts[dateStr].count++;
                            console.log(record)
                            const personName = record.name || record?.expand?.user?.name || 'UNKNOWN';
                            dateCounts[dateStr].people.push(personName);
                        });
                    }
                });

                const aggregatedDates = Object.entries(dateCounts)
                    .map(([date, data]) => ({
                        date,
                        count: data.count,
                        people: data.people.join(', ')
                    }))
                    .sort((a, b) => b.count - a.count || new Date(a.date) - new Date(b.date));

                // Display popular dates
                popularDatesDiv.innerHTML = '';
                if (aggregatedDates.length > 0) {
                    const maxCount = aggregatedDates[0].count;

                    aggregatedDates.forEach(item => {
                        const itemDiv = document.createElement('div');
                        itemDiv.classList.add('date-count-item');

                        if (item.count === 1) {
                            itemDiv.classList.add('single-attendee');
                        } else if (item.count === maxCount && maxCount > 1) {
                            itemDiv.classList.add('most-popular');
                        }
                        
                        const displayDate = new Date(item.date + 'T00:00:00').toLocaleDateString('en-US', {
                            weekday: 'long', 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric'
                        });

                        itemDiv.innerHTML = `
                            <div class="date-info">
                                <strong class="medium-text date-value">${displayDate}:</strong>
                                <span class="availability-count">${item.count} ${item.count === 1 ? 'person' : 'people'} available</span>
                            </div>
                            <p class="attendees-list small-text">Available: ${item.people}</p>
                            ${(item.count === maxCount && maxCount > 1) ? '<span class="chip primary extra small-padding round">Top Choice!</span>' : ''}
                        `;
                        popularDatesDiv.appendChild(itemDiv);
                    });
                } else {
                    popularDatesDiv.innerHTML = '<p class="small-text">No dates submitted yet.</p>';
                }

                // Display all submissions
                allSubmissionsUl.innerHTML = '';
                records.forEach(record => {
                    const li = document.createElement('li');
                    const datesString = record.available_dates
                        ? record.available_dates.map(d => {
                            const date = new Date(d + 'T00:00:00');
                            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        }).join(', ')
                        : 'No dates';
                    const displayName = record.name || record.expand.user.name || 'Anonymous';
                    const createdDate = new Date(record.created).toLocaleString();
                    li.innerHTML = `<strong>${displayName}</strong> available on: <span style="color: var(--secondary);">${datesString}</span> <em class="small-text" style="color: var(--on-surface-variant);">(Submitted: ${createdDate})</em>`;
                    allSubmissionsUl.appendChild(li);
                });

            } catch (error) {
                console.error("Error fetching results:", error);
                resultsError.textContent = `Failed to load results: ${error.message}`;
                resultsError.classList.remove('hidden');
                popularDatesDiv.innerHTML = '<p class="small-text">Error loading data.</p>';
                allSubmissionsUl.innerHTML = '<p class="small-text">Error loading data.</p>';
                updateConnectionStatus(`Error: ${error.message}`, true);
            } finally {
                resultsLoading.classList.add('hidden');
            }
        }

        dateForm.addEventListener('submit', async (event) => {
            event.preventDefault();

            if (!pb?.authStore?.isValid) {
                showMessage('You must sign in before submitting availability.', 'error');
                return;
            }

            submitLoading.classList.remove('hidden');
            document.getElementById('submitButton').setAttribute('disabled', 'true');
            messageArea.style.display = 'none';

            const user = pb.authStore.model;
            const name = (user?.name || user?.username || user?.email || 'ERROR').toUpperCase();

            const selectedDates = flatpickrInstance.selectedDates.map(date => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            });

            if (selectedDates.length === 0) {
                showMessage('Please select at least one date.', 'error');
                submitLoading.classList.add('hidden');
                document.getElementById('submitButton').removeAttribute('disabled');
                return;
            }

            const dataToSubmit = { 
                name: name, 
                available_dates: selectedDates,
                user: pb.authStore.model.id
            };

            try {
                // Check for existing submission
                let existing = null;
                try {
                    existing = await pb.collection(COLLECTION_NAME).getFirstListItem(
                        `user = "${pb.authStore.model.id}"`
                    );
                } catch (e) {
                    // No existing record found
                }

                if (existing) {
                    await pb.collection(COLLECTION_NAME).update(existing.id, dataToSubmit);
                    showMessage('Your availability was updated successfully!', 'success');
                } else {
                    await pb.collection(COLLECTION_NAME).create(dataToSubmit);
                    showMessage('Availability submitted successfully!', 'success');
                }
                
                dateForm.reset();
                flatpickrInstance.clear();
                if (typeof ui === 'function') ui('#upload-dates-dialog');
                
            } catch (error) {
                console.error("Error submitting form:", error);
                showMessage(`Submission failed: ${error.message}`, 'error');
                updateConnectionStatus(`Error submitting: ${error.message}`, true);
            } finally {
                submitLoading.classList.add('hidden');
                document.getElementById('submitButton').removeAttribute('disabled');
            }
        });

        // Load user's existing dates when signed in
        async function loadUserDates() {
            if (!pb?.authStore?.isValid) return;
            
            try {
                const existing = await pb.collection(COLLECTION_NAME).getFirstListItem(
                    `user = "${pb.authStore.model.id}"`
                );
                
                if (existing?.available_dates) {
                    flatpickrInstance.setDate(existing.available_dates, true);
                    const userName = pb.authStore.model.name || pb.authStore.model.username || '';
                    showMessage(`Welcome back${userName ? ', ' + userName : ''}! Your previous dates have been loaded.`, 'success', 3000);
                }
            } catch (err) {
                // No existing submission found
            }
        }

        // Initialize on DOM load
        document.addEventListener('DOMContentLoaded', async () => {
            initializeFlatpickr();
            await initializePocketBaseClient();
            
            // Check if returning from auth
            if (pb?.authStore?.isValid) {
                await loadUserDates();
            }
        });

        // Handle offline/online events
        window.addEventListener('offline', () => {
            updateConnectionStatus('Connection lost. You are offline.', true);
            showMessage('You appear to be offline. Changes will not be saved.', 'error', 0);
        });

        window.addEventListener('online', async () => {
            updateConnectionStatus('Connection restored. Re-initializing...', false);
            showMessage('You are back online. Reconnecting...', 'success', 3000);
            await initializePocketBaseClient();
        });
    </script>
</body>
</html>